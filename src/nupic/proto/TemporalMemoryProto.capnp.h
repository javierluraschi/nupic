// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: TemporalMemoryProto.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>

#if CAPNP_VERSION != 7000
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif

#include <nupic/proto/ConnectionsProto.capnp.h>
#include <nupic/proto/RandomProto.capnp.h>

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(c9b9492ef2f4352c);
CAPNP_DECLARE_SCHEMA(e2b21d556a35be26);
CAPNP_DECLARE_SCHEMA(9d7567256a72b29b);
CAPNP_DECLARE_SCHEMA(c99ed53aefde7038);

}  // namespace schemas
}  // namespace capnp


struct TemporalMemoryProto {
  TemporalMemoryProto() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct SegmentPath;
  struct SegmentUInt32Pair;
  struct SegmentUInt64Pair;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c9b9492ef2f4352c, 7, 9)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TemporalMemoryProto::SegmentPath {
  SegmentPath() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e2b21d556a35be26, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TemporalMemoryProto::SegmentUInt32Pair {
  SegmentUInt32Pair() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9d7567256a72b29b, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TemporalMemoryProto::SegmentUInt64Pair {
  SegmentUInt64Pair() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c99ed53aefde7038, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class TemporalMemoryProto::Reader {
public:
  typedef TemporalMemoryProto Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasColumnDimensions() const;
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader getColumnDimensions() const;

  inline  ::uint32_t getCellsPerColumn() const;

  inline  ::uint32_t getActivationThreshold() const;

  inline  ::uint32_t getLearningRadius() const;

  inline float getInitialPermanence() const;

  inline float getConnectedPermanence() const;

  inline  ::uint32_t getMinThreshold() const;

  inline  ::uint32_t getMaxNewSynapseCount() const;

  inline float getPermanenceIncrement() const;

  inline float getPermanenceDecrement() const;

  inline float getPredictedSegmentDecrement() const;

  inline  ::uint16_t getMaxSegmentsPerCell() const;

  inline  ::uint16_t getMaxSynapsesPerSegment() const;

  inline bool hasConnections() const;
  inline  ::ConnectionsProto::Reader getConnections() const;

  inline bool hasRandom() const;
  inline  ::RandomProto::Reader getRandom() const;

  inline bool hasActiveCells() const;
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader getActiveCells() const;

  inline bool hasWinnerCells() const;
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader getWinnerCells() const;

  inline bool hasActiveSegments() const;
  inline  ::capnp::List< ::TemporalMemoryProto::SegmentPath,  ::capnp::Kind::STRUCT>::Reader getActiveSegments() const;

  inline bool hasMatchingSegments() const;
  inline  ::capnp::List< ::TemporalMemoryProto::SegmentPath,  ::capnp::Kind::STRUCT>::Reader getMatchingSegments() const;

  inline bool hasNumActivePotentialSynapsesForSegment() const;
  inline  ::capnp::List< ::TemporalMemoryProto::SegmentUInt32Pair,  ::capnp::Kind::STRUCT>::Reader getNumActivePotentialSynapsesForSegment() const;

  inline  ::uint64_t getIteration() const;

  inline bool hasLastUsedIterationForSegment() const;
  inline  ::capnp::List< ::TemporalMemoryProto::SegmentUInt64Pair,  ::capnp::Kind::STRUCT>::Reader getLastUsedIterationForSegment() const;

  inline bool getCheckInputs() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TemporalMemoryProto::Builder {
public:
  typedef TemporalMemoryProto Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasColumnDimensions();
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder getColumnDimensions();
  inline void setColumnDimensions( ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setColumnDimensions(::kj::ArrayPtr<const  ::uint32_t> value);
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder initColumnDimensions(unsigned int size);
  inline void adoptColumnDimensions(::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>> disownColumnDimensions();

  inline  ::uint32_t getCellsPerColumn();
  inline void setCellsPerColumn( ::uint32_t value);

  inline  ::uint32_t getActivationThreshold();
  inline void setActivationThreshold( ::uint32_t value);

  inline  ::uint32_t getLearningRadius();
  inline void setLearningRadius( ::uint32_t value);

  inline float getInitialPermanence();
  inline void setInitialPermanence(float value);

  inline float getConnectedPermanence();
  inline void setConnectedPermanence(float value);

  inline  ::uint32_t getMinThreshold();
  inline void setMinThreshold( ::uint32_t value);

  inline  ::uint32_t getMaxNewSynapseCount();
  inline void setMaxNewSynapseCount( ::uint32_t value);

  inline float getPermanenceIncrement();
  inline void setPermanenceIncrement(float value);

  inline float getPermanenceDecrement();
  inline void setPermanenceDecrement(float value);

  inline float getPredictedSegmentDecrement();
  inline void setPredictedSegmentDecrement(float value);

  inline  ::uint16_t getMaxSegmentsPerCell();
  inline void setMaxSegmentsPerCell( ::uint16_t value);

  inline  ::uint16_t getMaxSynapsesPerSegment();
  inline void setMaxSynapsesPerSegment( ::uint16_t value);

  inline bool hasConnections();
  inline  ::ConnectionsProto::Builder getConnections();
  inline void setConnections( ::ConnectionsProto::Reader value);
  inline  ::ConnectionsProto::Builder initConnections();
  inline void adoptConnections(::capnp::Orphan< ::ConnectionsProto>&& value);
  inline ::capnp::Orphan< ::ConnectionsProto> disownConnections();

  inline bool hasRandom();
  inline  ::RandomProto::Builder getRandom();
  inline void setRandom( ::RandomProto::Reader value);
  inline  ::RandomProto::Builder initRandom();
  inline void adoptRandom(::capnp::Orphan< ::RandomProto>&& value);
  inline ::capnp::Orphan< ::RandomProto> disownRandom();

  inline bool hasActiveCells();
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder getActiveCells();
  inline void setActiveCells( ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setActiveCells(::kj::ArrayPtr<const  ::uint32_t> value);
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder initActiveCells(unsigned int size);
  inline void adoptActiveCells(::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>> disownActiveCells();

  inline bool hasWinnerCells();
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder getWinnerCells();
  inline void setWinnerCells( ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setWinnerCells(::kj::ArrayPtr<const  ::uint32_t> value);
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder initWinnerCells(unsigned int size);
  inline void adoptWinnerCells(::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>> disownWinnerCells();

  inline bool hasActiveSegments();
  inline  ::capnp::List< ::TemporalMemoryProto::SegmentPath,  ::capnp::Kind::STRUCT>::Builder getActiveSegments();
  inline void setActiveSegments( ::capnp::List< ::TemporalMemoryProto::SegmentPath,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::TemporalMemoryProto::SegmentPath,  ::capnp::Kind::STRUCT>::Builder initActiveSegments(unsigned int size);
  inline void adoptActiveSegments(::capnp::Orphan< ::capnp::List< ::TemporalMemoryProto::SegmentPath,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::TemporalMemoryProto::SegmentPath,  ::capnp::Kind::STRUCT>> disownActiveSegments();

  inline bool hasMatchingSegments();
  inline  ::capnp::List< ::TemporalMemoryProto::SegmentPath,  ::capnp::Kind::STRUCT>::Builder getMatchingSegments();
  inline void setMatchingSegments( ::capnp::List< ::TemporalMemoryProto::SegmentPath,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::TemporalMemoryProto::SegmentPath,  ::capnp::Kind::STRUCT>::Builder initMatchingSegments(unsigned int size);
  inline void adoptMatchingSegments(::capnp::Orphan< ::capnp::List< ::TemporalMemoryProto::SegmentPath,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::TemporalMemoryProto::SegmentPath,  ::capnp::Kind::STRUCT>> disownMatchingSegments();

  inline bool hasNumActivePotentialSynapsesForSegment();
  inline  ::capnp::List< ::TemporalMemoryProto::SegmentUInt32Pair,  ::capnp::Kind::STRUCT>::Builder getNumActivePotentialSynapsesForSegment();
  inline void setNumActivePotentialSynapsesForSegment( ::capnp::List< ::TemporalMemoryProto::SegmentUInt32Pair,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::TemporalMemoryProto::SegmentUInt32Pair,  ::capnp::Kind::STRUCT>::Builder initNumActivePotentialSynapsesForSegment(unsigned int size);
  inline void adoptNumActivePotentialSynapsesForSegment(::capnp::Orphan< ::capnp::List< ::TemporalMemoryProto::SegmentUInt32Pair,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::TemporalMemoryProto::SegmentUInt32Pair,  ::capnp::Kind::STRUCT>> disownNumActivePotentialSynapsesForSegment();

  inline  ::uint64_t getIteration();
  inline void setIteration( ::uint64_t value);

  inline bool hasLastUsedIterationForSegment();
  inline  ::capnp::List< ::TemporalMemoryProto::SegmentUInt64Pair,  ::capnp::Kind::STRUCT>::Builder getLastUsedIterationForSegment();
  inline void setLastUsedIterationForSegment( ::capnp::List< ::TemporalMemoryProto::SegmentUInt64Pair,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::TemporalMemoryProto::SegmentUInt64Pair,  ::capnp::Kind::STRUCT>::Builder initLastUsedIterationForSegment(unsigned int size);
  inline void adoptLastUsedIterationForSegment(::capnp::Orphan< ::capnp::List< ::TemporalMemoryProto::SegmentUInt64Pair,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::TemporalMemoryProto::SegmentUInt64Pair,  ::capnp::Kind::STRUCT>> disownLastUsedIterationForSegment();

  inline bool getCheckInputs();
  inline void setCheckInputs(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TemporalMemoryProto::Pipeline {
public:
  typedef TemporalMemoryProto Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::ConnectionsProto::Pipeline getConnections();
  inline  ::RandomProto::Pipeline getRandom();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TemporalMemoryProto::SegmentPath::Reader {
public:
  typedef SegmentPath Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getCell() const;

  inline  ::uint32_t getIdxOnCell() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TemporalMemoryProto::SegmentPath::Builder {
public:
  typedef SegmentPath Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getCell();
  inline void setCell( ::uint32_t value);

  inline  ::uint32_t getIdxOnCell();
  inline void setIdxOnCell( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TemporalMemoryProto::SegmentPath::Pipeline {
public:
  typedef SegmentPath Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TemporalMemoryProto::SegmentUInt32Pair::Reader {
public:
  typedef SegmentUInt32Pair Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getCell() const;

  inline  ::uint32_t getIdxOnCell() const;

  inline  ::uint32_t getNumber() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TemporalMemoryProto::SegmentUInt32Pair::Builder {
public:
  typedef SegmentUInt32Pair Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getCell();
  inline void setCell( ::uint32_t value);

  inline  ::uint32_t getIdxOnCell();
  inline void setIdxOnCell( ::uint32_t value);

  inline  ::uint32_t getNumber();
  inline void setNumber( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TemporalMemoryProto::SegmentUInt32Pair::Pipeline {
public:
  typedef SegmentUInt32Pair Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TemporalMemoryProto::SegmentUInt64Pair::Reader {
public:
  typedef SegmentUInt64Pair Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getCell() const;

  inline  ::uint32_t getIdxOnCell() const;

  inline  ::uint64_t getNumber() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TemporalMemoryProto::SegmentUInt64Pair::Builder {
public:
  typedef SegmentUInt64Pair Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getCell();
  inline void setCell( ::uint32_t value);

  inline  ::uint32_t getIdxOnCell();
  inline void setIdxOnCell( ::uint32_t value);

  inline  ::uint64_t getNumber();
  inline void setNumber( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TemporalMemoryProto::SegmentUInt64Pair::Pipeline {
public:
  typedef SegmentUInt64Pair Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline bool TemporalMemoryProto::Reader::hasColumnDimensions() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TemporalMemoryProto::Builder::hasColumnDimensions() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader TemporalMemoryProto::Reader::getColumnDimensions() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder TemporalMemoryProto::Builder::getColumnDimensions() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TemporalMemoryProto::Builder::setColumnDimensions( ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void TemporalMemoryProto::Builder::setColumnDimensions(::kj::ArrayPtr<const  ::uint32_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder TemporalMemoryProto::Builder::initColumnDimensions(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void TemporalMemoryProto::Builder::adoptColumnDimensions(
    ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>> TemporalMemoryProto::Builder::disownColumnDimensions() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint32_t TemporalMemoryProto::Reader::getCellsPerColumn() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t TemporalMemoryProto::Builder::getCellsPerColumn() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TemporalMemoryProto::Builder::setCellsPerColumn( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t TemporalMemoryProto::Reader::getActivationThreshold() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t TemporalMemoryProto::Builder::getActivationThreshold() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void TemporalMemoryProto::Builder::setActivationThreshold( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t TemporalMemoryProto::Reader::getLearningRadius() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t TemporalMemoryProto::Builder::getLearningRadius() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void TemporalMemoryProto::Builder::setLearningRadius( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline float TemporalMemoryProto::Reader::getInitialPermanence() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline float TemporalMemoryProto::Builder::getInitialPermanence() {
  return _builder.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void TemporalMemoryProto::Builder::setInitialPermanence(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline float TemporalMemoryProto::Reader::getConnectedPermanence() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline float TemporalMemoryProto::Builder::getConnectedPermanence() {
  return _builder.getDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void TemporalMemoryProto::Builder::setConnectedPermanence(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t TemporalMemoryProto::Reader::getMinThreshold() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t TemporalMemoryProto::Builder::getMinThreshold() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}
inline void TemporalMemoryProto::Builder::setMinThreshold( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t TemporalMemoryProto::Reader::getMaxNewSynapseCount() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t TemporalMemoryProto::Builder::getMaxNewSynapseCount() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}
inline void TemporalMemoryProto::Builder::setMaxNewSynapseCount( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS, value);
}

inline float TemporalMemoryProto::Reader::getPermanenceIncrement() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS);
}

inline float TemporalMemoryProto::Builder::getPermanenceIncrement() {
  return _builder.getDataField<float>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS);
}
inline void TemporalMemoryProto::Builder::setPermanenceIncrement(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS, value);
}

inline float TemporalMemoryProto::Reader::getPermanenceDecrement() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS);
}

inline float TemporalMemoryProto::Builder::getPermanenceDecrement() {
  return _builder.getDataField<float>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS);
}
inline void TemporalMemoryProto::Builder::setPermanenceDecrement(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS, value);
}

inline float TemporalMemoryProto::Reader::getPredictedSegmentDecrement() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS);
}

inline float TemporalMemoryProto::Builder::getPredictedSegmentDecrement() {
  return _builder.getDataField<float>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS);
}
inline void TemporalMemoryProto::Builder::setPredictedSegmentDecrement(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<9>() * ::capnp::ELEMENTS, value);
}

inline  ::uint16_t TemporalMemoryProto::Reader::getMaxSegmentsPerCell() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<20>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t TemporalMemoryProto::Builder::getMaxSegmentsPerCell() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<20>() * ::capnp::ELEMENTS);
}
inline void TemporalMemoryProto::Builder::setMaxSegmentsPerCell( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<20>() * ::capnp::ELEMENTS, value);
}

inline  ::uint16_t TemporalMemoryProto::Reader::getMaxSynapsesPerSegment() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<21>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t TemporalMemoryProto::Builder::getMaxSynapsesPerSegment() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<21>() * ::capnp::ELEMENTS);
}
inline void TemporalMemoryProto::Builder::setMaxSynapsesPerSegment( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<21>() * ::capnp::ELEMENTS, value);
}

inline bool TemporalMemoryProto::Reader::hasConnections() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool TemporalMemoryProto::Builder::hasConnections() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::ConnectionsProto::Reader TemporalMemoryProto::Reader::getConnections() const {
  return ::capnp::_::PointerHelpers< ::ConnectionsProto>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::ConnectionsProto::Builder TemporalMemoryProto::Builder::getConnections() {
  return ::capnp::_::PointerHelpers< ::ConnectionsProto>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::ConnectionsProto::Pipeline TemporalMemoryProto::Pipeline::getConnections() {
  return  ::ConnectionsProto::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void TemporalMemoryProto::Builder::setConnections( ::ConnectionsProto::Reader value) {
  ::capnp::_::PointerHelpers< ::ConnectionsProto>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::ConnectionsProto::Builder TemporalMemoryProto::Builder::initConnections() {
  return ::capnp::_::PointerHelpers< ::ConnectionsProto>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void TemporalMemoryProto::Builder::adoptConnections(
    ::capnp::Orphan< ::ConnectionsProto>&& value) {
  ::capnp::_::PointerHelpers< ::ConnectionsProto>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::ConnectionsProto> TemporalMemoryProto::Builder::disownConnections() {
  return ::capnp::_::PointerHelpers< ::ConnectionsProto>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool TemporalMemoryProto::Reader::hasRandom() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool TemporalMemoryProto::Builder::hasRandom() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::RandomProto::Reader TemporalMemoryProto::Reader::getRandom() const {
  return ::capnp::_::PointerHelpers< ::RandomProto>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::RandomProto::Builder TemporalMemoryProto::Builder::getRandom() {
  return ::capnp::_::PointerHelpers< ::RandomProto>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::RandomProto::Pipeline TemporalMemoryProto::Pipeline::getRandom() {
  return  ::RandomProto::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void TemporalMemoryProto::Builder::setRandom( ::RandomProto::Reader value) {
  ::capnp::_::PointerHelpers< ::RandomProto>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::RandomProto::Builder TemporalMemoryProto::Builder::initRandom() {
  return ::capnp::_::PointerHelpers< ::RandomProto>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void TemporalMemoryProto::Builder::adoptRandom(
    ::capnp::Orphan< ::RandomProto>&& value) {
  ::capnp::_::PointerHelpers< ::RandomProto>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::RandomProto> TemporalMemoryProto::Builder::disownRandom() {
  return ::capnp::_::PointerHelpers< ::RandomProto>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool TemporalMemoryProto::Reader::hasActiveCells() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool TemporalMemoryProto::Builder::hasActiveCells() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader TemporalMemoryProto::Reader::getActiveCells() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder TemporalMemoryProto::Builder::getActiveCells() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void TemporalMemoryProto::Builder::setActiveCells( ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline void TemporalMemoryProto::Builder::setActiveCells(::kj::ArrayPtr<const  ::uint32_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder TemporalMemoryProto::Builder::initActiveCells(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), size);
}
inline void TemporalMemoryProto::Builder::adoptActiveCells(
    ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>> TemporalMemoryProto::Builder::disownActiveCells() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool TemporalMemoryProto::Reader::hasWinnerCells() const {
  return !_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline bool TemporalMemoryProto::Builder::hasWinnerCells() {
  return !_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader TemporalMemoryProto::Reader::getWinnerCells() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder TemporalMemoryProto::Builder::getWinnerCells() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline void TemporalMemoryProto::Builder::setWinnerCells( ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), value);
}
inline void TemporalMemoryProto::Builder::setWinnerCells(::kj::ArrayPtr<const  ::uint32_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder TemporalMemoryProto::Builder::initWinnerCells(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), size);
}
inline void TemporalMemoryProto::Builder::adoptWinnerCells(
    ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>> TemporalMemoryProto::Builder::disownWinnerCells() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}

inline bool TemporalMemoryProto::Reader::hasActiveSegments() const {
  return !_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline bool TemporalMemoryProto::Builder::hasActiveSegments() {
  return !_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::TemporalMemoryProto::SegmentPath,  ::capnp::Kind::STRUCT>::Reader TemporalMemoryProto::Reader::getActiveSegments() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::TemporalMemoryProto::SegmentPath,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::TemporalMemoryProto::SegmentPath,  ::capnp::Kind::STRUCT>::Builder TemporalMemoryProto::Builder::getActiveSegments() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::TemporalMemoryProto::SegmentPath,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline void TemporalMemoryProto::Builder::setActiveSegments( ::capnp::List< ::TemporalMemoryProto::SegmentPath,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::TemporalMemoryProto::SegmentPath,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::TemporalMemoryProto::SegmentPath,  ::capnp::Kind::STRUCT>::Builder TemporalMemoryProto::Builder::initActiveSegments(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::TemporalMemoryProto::SegmentPath,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), size);
}
inline void TemporalMemoryProto::Builder::adoptActiveSegments(
    ::capnp::Orphan< ::capnp::List< ::TemporalMemoryProto::SegmentPath,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::TemporalMemoryProto::SegmentPath,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::TemporalMemoryProto::SegmentPath,  ::capnp::Kind::STRUCT>> TemporalMemoryProto::Builder::disownActiveSegments() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::TemporalMemoryProto::SegmentPath,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}

inline bool TemporalMemoryProto::Reader::hasMatchingSegments() const {
  return !_reader.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS).isNull();
}
inline bool TemporalMemoryProto::Builder::hasMatchingSegments() {
  return !_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::TemporalMemoryProto::SegmentPath,  ::capnp::Kind::STRUCT>::Reader TemporalMemoryProto::Reader::getMatchingSegments() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::TemporalMemoryProto::SegmentPath,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::TemporalMemoryProto::SegmentPath,  ::capnp::Kind::STRUCT>::Builder TemporalMemoryProto::Builder::getMatchingSegments() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::TemporalMemoryProto::SegmentPath,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}
inline void TemporalMemoryProto::Builder::setMatchingSegments( ::capnp::List< ::TemporalMemoryProto::SegmentPath,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::TemporalMemoryProto::SegmentPath,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::TemporalMemoryProto::SegmentPath,  ::capnp::Kind::STRUCT>::Builder TemporalMemoryProto::Builder::initMatchingSegments(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::TemporalMemoryProto::SegmentPath,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), size);
}
inline void TemporalMemoryProto::Builder::adoptMatchingSegments(
    ::capnp::Orphan< ::capnp::List< ::TemporalMemoryProto::SegmentPath,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::TemporalMemoryProto::SegmentPath,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::TemporalMemoryProto::SegmentPath,  ::capnp::Kind::STRUCT>> TemporalMemoryProto::Builder::disownMatchingSegments() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::TemporalMemoryProto::SegmentPath,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}

inline bool TemporalMemoryProto::Reader::hasNumActivePotentialSynapsesForSegment() const {
  return !_reader.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS).isNull();
}
inline bool TemporalMemoryProto::Builder::hasNumActivePotentialSynapsesForSegment() {
  return !_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::TemporalMemoryProto::SegmentUInt32Pair,  ::capnp::Kind::STRUCT>::Reader TemporalMemoryProto::Reader::getNumActivePotentialSynapsesForSegment() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::TemporalMemoryProto::SegmentUInt32Pair,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::TemporalMemoryProto::SegmentUInt32Pair,  ::capnp::Kind::STRUCT>::Builder TemporalMemoryProto::Builder::getNumActivePotentialSynapsesForSegment() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::TemporalMemoryProto::SegmentUInt32Pair,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}
inline void TemporalMemoryProto::Builder::setNumActivePotentialSynapsesForSegment( ::capnp::List< ::TemporalMemoryProto::SegmentUInt32Pair,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::TemporalMemoryProto::SegmentUInt32Pair,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::TemporalMemoryProto::SegmentUInt32Pair,  ::capnp::Kind::STRUCT>::Builder TemporalMemoryProto::Builder::initNumActivePotentialSynapsesForSegment(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::TemporalMemoryProto::SegmentUInt32Pair,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS), size);
}
inline void TemporalMemoryProto::Builder::adoptNumActivePotentialSynapsesForSegment(
    ::capnp::Orphan< ::capnp::List< ::TemporalMemoryProto::SegmentUInt32Pair,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::TemporalMemoryProto::SegmentUInt32Pair,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::TemporalMemoryProto::SegmentUInt32Pair,  ::capnp::Kind::STRUCT>> TemporalMemoryProto::Builder::disownNumActivePotentialSynapsesForSegment() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::TemporalMemoryProto::SegmentUInt32Pair,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}

inline  ::uint64_t TemporalMemoryProto::Reader::getIteration() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t TemporalMemoryProto::Builder::getIteration() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}
inline void TemporalMemoryProto::Builder::setIteration( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS, value);
}

inline bool TemporalMemoryProto::Reader::hasLastUsedIterationForSegment() const {
  return !_reader.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS).isNull();
}
inline bool TemporalMemoryProto::Builder::hasLastUsedIterationForSegment() {
  return !_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::TemporalMemoryProto::SegmentUInt64Pair,  ::capnp::Kind::STRUCT>::Reader TemporalMemoryProto::Reader::getLastUsedIterationForSegment() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::TemporalMemoryProto::SegmentUInt64Pair,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::TemporalMemoryProto::SegmentUInt64Pair,  ::capnp::Kind::STRUCT>::Builder TemporalMemoryProto::Builder::getLastUsedIterationForSegment() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::TemporalMemoryProto::SegmentUInt64Pair,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS));
}
inline void TemporalMemoryProto::Builder::setLastUsedIterationForSegment( ::capnp::List< ::TemporalMemoryProto::SegmentUInt64Pair,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::TemporalMemoryProto::SegmentUInt64Pair,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::TemporalMemoryProto::SegmentUInt64Pair,  ::capnp::Kind::STRUCT>::Builder TemporalMemoryProto::Builder::initLastUsedIterationForSegment(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::TemporalMemoryProto::SegmentUInt64Pair,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS), size);
}
inline void TemporalMemoryProto::Builder::adoptLastUsedIterationForSegment(
    ::capnp::Orphan< ::capnp::List< ::TemporalMemoryProto::SegmentUInt64Pair,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::TemporalMemoryProto::SegmentUInt64Pair,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::TemporalMemoryProto::SegmentUInt64Pair,  ::capnp::Kind::STRUCT>> TemporalMemoryProto::Builder::disownLastUsedIterationForSegment() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::TemporalMemoryProto::SegmentUInt64Pair,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS));
}

inline bool TemporalMemoryProto::Reader::getCheckInputs() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<352>() * ::capnp::ELEMENTS);
}

inline bool TemporalMemoryProto::Builder::getCheckInputs() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<352>() * ::capnp::ELEMENTS);
}
inline void TemporalMemoryProto::Builder::setCheckInputs(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<352>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t TemporalMemoryProto::SegmentPath::Reader::getCell() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t TemporalMemoryProto::SegmentPath::Builder::getCell() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TemporalMemoryProto::SegmentPath::Builder::setCell( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t TemporalMemoryProto::SegmentPath::Reader::getIdxOnCell() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t TemporalMemoryProto::SegmentPath::Builder::getIdxOnCell() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void TemporalMemoryProto::SegmentPath::Builder::setIdxOnCell( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t TemporalMemoryProto::SegmentUInt32Pair::Reader::getCell() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t TemporalMemoryProto::SegmentUInt32Pair::Builder::getCell() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TemporalMemoryProto::SegmentUInt32Pair::Builder::setCell( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t TemporalMemoryProto::SegmentUInt32Pair::Reader::getIdxOnCell() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t TemporalMemoryProto::SegmentUInt32Pair::Builder::getIdxOnCell() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void TemporalMemoryProto::SegmentUInt32Pair::Builder::setIdxOnCell( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t TemporalMemoryProto::SegmentUInt32Pair::Reader::getNumber() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t TemporalMemoryProto::SegmentUInt32Pair::Builder::getNumber() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void TemporalMemoryProto::SegmentUInt32Pair::Builder::setNumber( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t TemporalMemoryProto::SegmentUInt64Pair::Reader::getCell() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t TemporalMemoryProto::SegmentUInt64Pair::Builder::getCell() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TemporalMemoryProto::SegmentUInt64Pair::Builder::setCell( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t TemporalMemoryProto::SegmentUInt64Pair::Reader::getIdxOnCell() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t TemporalMemoryProto::SegmentUInt64Pair::Builder::getIdxOnCell() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void TemporalMemoryProto::SegmentUInt64Pair::Builder::setIdxOnCell( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t TemporalMemoryProto::SegmentUInt64Pair::Reader::getNumber() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t TemporalMemoryProto::SegmentUInt64Pair::Builder::getNumber() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void TemporalMemoryProto::SegmentUInt64Pair::Builder::setNumber( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}


